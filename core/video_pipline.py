# core/video_pipeline.py - ENHANCED VERSION

import os
import tempfile
import shutil
from typing import List, Dict
from dataclasses import dataclass, field

# Import all operations
from core.operations.filler_removal import remove_fillers
from core.operations.silence_removal import remove_silence
from core.operations.audio_enhance import enhance_audio
from core.operations.subtitle_generator import add_subtitles
from core.operations.music_mixer import add_background_music

# Import new advanced operations
from core.operations.emotion_analyzer import analyze_emotions
from core.operations.key_moment_detector import identify_key_moments
from core.operations.color_correction import color_correction
from core.operations.platform_optimizer import platform_optimize
from core.operations.quality_evaluator import evaluate_quality

@dataclass
class Operation:
    """Represents a single video editing operation"""
    name: str
    priority: int
    params: Dict = field(default_factory=dict)

class EnhancedVideoPipeline:
    """
    Enhanced dynamic video processing pipeline with:
    - Emotional Intelligence
    - Creative Decision Making
    - Narrative Restructuring
    - Multi-Platform Optimization
    """
    
    def __init__(self):
        self.operations_map = {
            # Core operations
            "remove_fillers": self._op_remove_fillers,
            "remove_silence": self._op_remove_silence,
            "enhance_audio": self._op_enhance_audio,
            "add_subtitles": self._op_add_subtitles,
            "add_music": self._op_add_music,
            
            # Advanced operations
            "analyze_emotions": self._op_analyze_emotions,
            "identify_key_moments": self._op_identify_key_moments,
            "color_correction": self._op_color_correction,
            "platform_optimize": self._op_platform_optimize,
            "evaluate_quality": self._op_evaluate_quality,
        }
        
        self.temp_files = []
        self.metadata = {
            "emotions": [],
            "key_moments": [],
            "quality_metrics": {}
        }
    
    def process(
        self,
        input_path: str,
        operations: List[Operation],
        output_path: str = None
    ) -> Dict:
        """
        Execute video processing pipeline dynamically
        Returns: dict with output_path and metadata
        """
        current_path = input_path
        
        # Sort by priority
        operations = sorted(operations, key=lambda op: op.priority)
        
        print(f"ðŸŽ¬ Starting ENHANCED pipeline with {len(operations)} operations")
        print("   Features: Emotion Analysis + Creative Decisions + Platform Optimization")
        
        for i, operation in enumerate(operations):
            print(f"  [{i+1}/{len(operations)}] {operation.name}")
            
            op_func = self.operations_map.get(operation.name)
            if not op_func:
                print(f"    âš ï¸  Unknown operation: {operation.name}")
                continue
            
            temp_output = tempfile.mktemp(suffix=".mp4")
            self.temp_files.append(temp_output)
            
            try:
                op_func(current_path, temp_output, **operation.params)
                current_path = temp_output
                print(f"    âœ… Completed")
                
                # Load metadata if generated
                self._load_operation_metadata(temp_output, operation.name)
                
            except Exception as e:
                print(f"    âŒ Error: {e}")
                continue
        
        # Save final output
        if output_path is None:
            output_path = tempfile.mktemp(suffix=".mp4")
        
        shutil.copy2(current_path, output_path)
        self._cleanup()
        
        print("âœ… Enhanced pipeline completed!")
        print(f"   Generated: {output_path}")
        if self.metadata["emotions"]:
            print(f"   Emotions analyzed: {len(self.metadata['emotions'])} points")
        if self.metadata["key_moments"]:
            print(f"   Key moments: {len(self.metadata['key_moments'])}")
        
        return {
            "output_path": output_path,
            "metadata": self.metadata
        }
    
    def _load_operation_metadata(self, output_path: str, operation_name: str):
        """Load metadata generated by operations"""
        import json
        
        try:
            if operation_name == "analyze_emotions":
                emotion_file = output_path.replace('.mp4', '_emotions.json')
                if os.path.exists(emotion_file):
                    with open(emotion_file, 'r') as f:
                        self.metadata["emotions"] = json.load(f)
                    os.remove(emotion_file)
            
            elif operation_name == "identify_key_moments":
                moment_file = output_path.replace('.mp4', '_moments.json')
                if os.path.exists(moment_file):
                    with open(moment_file, 'r') as f:
                        self.metadata["key_moments"] = json.load(f)
                    os.remove(moment_file)
            
            elif operation_name == "evaluate_quality":
                quality_file = output_path.replace('.mp4', '_quality.json')
                if os.path.exists(quality_file):
                    with open(quality_file, 'r') as f:
                        self.metadata["quality_metrics"] = json.load(f)
                    os.remove(quality_file)
        except:
            pass
    
    # ========== CORE OPERATIONS ==========
    
    def _op_remove_fillers(self, input_path: str, output_path: str, **kwargs):
        remove_fillers(input_path, output_path)
    
    def _op_remove_silence(self, input_path: str, output_path: str, **kwargs):
        remove_silence(input_path, output_path)
    
    def _op_enhance_audio(self, input_path: str, output_path: str, **kwargs):
        enhance_audio(input_path, output_path)
    
    def _op_add_subtitles(self, input_path: str, output_path: str, **kwargs):
        style = kwargs.get("style", "standard")
        add_subtitles(input_path, output_path, style)
    
    def _op_add_music(self, input_path: str, output_path: str, **kwargs):
        music_path = kwargs.get("music_path")
        volume = kwargs.get("volume", 0.15)
        mood = kwargs.get("mood", "upbeat")
        
        # Select music based on mood if no path provided
        if not music_path:
            music_path = self._select_music_by_mood(mood)
        
        add_background_music(input_path, output_path, music_path, volume)
    
    # ========== ADVANCED OPERATIONS ==========
    
    def _op_analyze_emotions(self, input_path: str, output_path: str, **kwargs):
        track_faces = kwargs.get("track_faces", True)
        analyze_voice = kwargs.get("analyze_voice", True)
        analyze_emotions(input_path, output_path, track_faces, analyze_voice)
    
    def _op_identify_key_moments(self, input_path: str, output_path: str, **kwargs):
        emotion_threshold = kwargs.get("emotion_threshold", 0.6)
        identify_key_moments(input_path, output_path, emotion_threshold)
    
    def _op_color_correction(self, input_path: str, output_path: str, **kwargs):
        mood = kwargs.get("mood", "warm")
        color_correction(input_path, output_path, mood)
    
    def _op_platform_optimize(self, input_path: str, output_path: str, **kwargs):
        platform = kwargs.get("platform", "youtube")
        platform_optimize(input_path, output_path, platform)
    
    def _op_evaluate_quality(self, input_path: str, output_path: str, **kwargs):
        evaluate_quality(input_path, output_path)
    
    # ========== HELPER METHODS ==========
    
    def _select_music_by_mood(self, mood: str) -> str:
        """Select appropriate music file based on mood"""
        music_map = {
            "upbeat": "assets/music/upbeat.mp3",
            "calm": "assets/music/calm.mp3",
            "dramatic": "assets/music/dramatic.mp3",
            "cinematic": "assets/music/cinematic.mp3"
        }
        
        music_path = music_map.get(mood, "assets/music/default.mp3")
        
        # Return None if file doesn't exist
        if not os.path.exists(music_path):
            return None
        
        return music_path
    
    def _cleanup(self):
        """Remove temp files"""
        for temp_file in self.temp_files:
            try:
                if os.path.exists(temp_file):
                    os.remove(temp_file)
            except:
                pass
        self.temp_files.clear()


# Backward compatibility - alias to new class
VideoPipeline = EnhancedVideoPipeline